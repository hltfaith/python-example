

该pty模块定义了处理伪终端概念的操作：启动另一个进程并能够以编程方式写入和读取其控制终端。

因为伪终端处理是高度依赖于平台的，所以有代码只对Linux执行。（Linux代码应该可以在其他平台上工作，但尚未经过测试。）

该pty模块定义了以下功能：

pty.fork()

Fork。 将孩子的控制终端连接到一个伪终端。 返回值是（pid，fd）。 请注意，孩子获得pid 0，并且fd无效。 父级的返回值是孩子的PID，fd是连接到孩子的控制终端（也是孩子的标准输入和输出）的文件描述符。

pty.openpty()

打开一个新的伪终端对，如果可能，使用os.openpty（）或通用Unix系统的仿真代码。 分别为主机和从机返回一对文件描述符（主机，从机）。

pty.spawn(argv[, master_read[, stdin_read]])

产生一个进程，并将其控制终端与当前进程的标准io连接起来。这常常被用来挡住坚持从控制终端读取的程序。

函数 master_read 和 stdin_read 应该是从文件描述符中读取的函数。每次调用默认设置时都会尝试读取1024个字节。


