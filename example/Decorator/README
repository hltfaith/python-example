
装饰器示例


当写完这段代码后（函数未被执行、未被执行、未被执行），python解释器就会从上到下解释代码，步骤如下：

def w1(func):  ==>将w1函数加载到内存
@w1
没错，从表面上看解释器仅仅会解释这两句代码，因为函数在没有被调用之前其内部代码不会被执行。

从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章，@函数名 是python的一种语法糖。

如上例@w1内部会执行一下操作：

执行w1函数，并将 @w1 下面的 函数 作为w1函数的参数，即：@w1 等价于 w1(f1)
所以，内部就会去执行：
    def inner:
        #验证
        return f1()   # func是参数，此时 func 等于 f1
    return inner     # 返回的 inner，inner代表的是函数，非执行函数
其实就是将原来的 f1 函数塞进另外一个函数中
将执行完的 w1 函数返回值赋值给@w1下面的函数的函数名
w1函数的返回值是：
   def inner:
        #验证
        return 原来f1()  # 此处的 f1 表示原来的f1函数
然后，将此返回值再重新赋值给 f1，即：
新f1 = def inner:
            #验证
            return 原来f1() 
所以，以后业务部门想要执行 f1 函数时，就会执行 新f1 函数，在 新f1 函数内部先执行验证，再执行原来的f1函数，然后将 原来f1 函数的返回值 返回给了业务调用者。
如此一来， 即执行了验证的功能，又执行了原来f1函数的内容，并将原f1函数返回值 返回给业务调用着






